// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_CHATTY_H_
#define FLATBUFFERS_GENERATED_MODEL_CHATTY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace chatty {

struct Tensor;
struct TensorBuilder;

struct ScaleInfo;
struct ScaleInfoBuilder;

struct Norm;
struct NormBuilder;

struct LinearLayer;
struct LinearLayerBuilder;

struct AttentionLayer;
struct AttentionLayerBuilder;

struct FFNLayer;
struct FFNLayerBuilder;

struct TransformerLayer;
struct TransformerLayerBuilder;

struct Model;
struct ModelBuilder;

inline const ::flatbuffers::TypeTable *TensorTypeTable();

inline const ::flatbuffers::TypeTable *ScaleInfoTypeTable();

inline const ::flatbuffers::TypeTable *NormTypeTable();

inline const ::flatbuffers::TypeTable *LinearLayerTypeTable();

inline const ::flatbuffers::TypeTable *AttentionLayerTypeTable();

inline const ::flatbuffers::TypeTable *FFNLayerTypeTable();

inline const ::flatbuffers::TypeTable *TransformerLayerTypeTable();

inline const ::flatbuffers::TypeTable *ModelTypeTable();

enum DType : int8_t {
  DType_NONE = 0,
  DType_INT8 = 1,
  DType_UINT8 = 2,
  DType_INT16 = 3,
  DType_UINT16 = 4,
  DType_INT32 = 5,
  DType_UINT32 = 6,
  DType_INT64 = 7,
  DType_UINT64 = 8,
  DType_FLOAT32 = 9,
  DType_FLOAT16 = 10,
  DType_FLOAT8 = 11,
  DType_BFLOAT16 = 12,
  DType_INT4 = 13,
  DType_MIN = DType_NONE,
  DType_MAX = DType_INT4
};

inline const DType (&EnumValuesDType())[14] {
  static const DType values[] = {
    DType_NONE,
    DType_INT8,
    DType_UINT8,
    DType_INT16,
    DType_UINT16,
    DType_INT32,
    DType_UINT32,
    DType_INT64,
    DType_UINT64,
    DType_FLOAT32,
    DType_FLOAT16,
    DType_FLOAT8,
    DType_BFLOAT16,
    DType_INT4
  };
  return values;
}

inline const char * const *EnumNamesDType() {
  static const char * const names[15] = {
    "NONE",
    "INT8",
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT16",
    "FLOAT8",
    "BFLOAT16",
    "INT4",
    nullptr
  };
  return names;
}

inline const char *EnumNameDType(DType e) {
  if (::flatbuffers::IsOutRange(e, DType_NONE, DType_INT4)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDType()[index];
}

enum ActivationBits : int8_t {
  ActivationBits_INT4 = 0,
  ActivationBits_INT8 = 1,
  ActivationBits_INT16 = 2,
  ActivationBits_FP16 = 3,
  ActivationBits_MIN = ActivationBits_INT4,
  ActivationBits_MAX = ActivationBits_FP16
};

inline const ActivationBits (&EnumValuesActivationBits())[4] {
  static const ActivationBits values[] = {
    ActivationBits_INT4,
    ActivationBits_INT8,
    ActivationBits_INT16,
    ActivationBits_FP16
  };
  return values;
}

inline const char * const *EnumNamesActivationBits() {
  static const char * const names[5] = {
    "INT4",
    "INT8",
    "INT16",
    "FP16",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationBits(ActivationBits e) {
  if (::flatbuffers::IsOutRange(e, ActivationBits_INT4, ActivationBits_FP16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationBits()[index];
}

enum ActLayer : int8_t {
  ActLayer_NONE = 0,
  ActLayer_RELU = 1,
  ActLayer_GELU = 2,
  ActLayer_SWISH = 3,
  ActLayer_SIGMOID = 4,
  ActLayer_TANH = 5,
  ActLayer_SOFTMAX = 6,
  ActLayer_MIN = ActLayer_NONE,
  ActLayer_MAX = ActLayer_SOFTMAX
};

inline const ActLayer (&EnumValuesActLayer())[7] {
  static const ActLayer values[] = {
    ActLayer_NONE,
    ActLayer_RELU,
    ActLayer_GELU,
    ActLayer_SWISH,
    ActLayer_SIGMOID,
    ActLayer_TANH,
    ActLayer_SOFTMAX
  };
  return values;
}

inline const char * const *EnumNamesActLayer() {
  static const char * const names[8] = {
    "NONE",
    "RELU",
    "GELU",
    "SWISH",
    "SIGMOID",
    "TANH",
    "SOFTMAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameActLayer(ActLayer e) {
  if (::flatbuffers::IsOutRange(e, ActLayer_NONE, ActLayer_SOFTMAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActLayer()[index];
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHAPE = 6,
    VT_DTYPE = 8,
    VT_OFFSET = 10,
    VT_SCALE = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  chatty::DType dtype() const {
    return static_cast<chatty::DType>(GetField<int8_t>(VT_DTYPE, 0));
  }
  int64_t offset() const {
    return GetField<int64_t>(VT_OFFSET, 0);
  }
  const chatty::ScaleInfo *scale() const {
    return GetPointer<const chatty::ScaleInfo *>(VT_SCALE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_OFFSET, 8) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyTable(scale()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_dtype(chatty::DType dtype) {
    fbb_.AddElement<int8_t>(Tensor::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_offset(int64_t offset) {
    fbb_.AddElement<int64_t>(Tensor::VT_OFFSET, offset, 0);
  }
  void add_scale(::flatbuffers::Offset<chatty::ScaleInfo> scale) {
    fbb_.AddOffset(Tensor::VT_SCALE, scale);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    fbb_.Required(o, Tensor::VT_NAME);
    fbb_.Required(o, Tensor::VT_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    chatty::DType dtype = chatty::DType_NONE,
    int64_t offset = 0,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_scale(scale);
  builder_.add_shape(shape);
  builder_.add_name(name);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<int32_t> *shape = nullptr,
    chatty::DType dtype = chatty::DType_NONE,
    int64_t offset = 0,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return chatty::CreateTensor(
      _fbb,
      name__,
      shape__,
      dtype,
      offset,
      scale);
}

struct ScaleInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScaleInfoBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SCALE = 6,
    VT_ZERO_POINT = 8,
    VT_DTYPE = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  chatty::DType dtype() const {
    return static_cast<chatty::DType>(GetField<int8_t>(VT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct ScaleInfoBuilder {
  typedef ScaleInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ScaleInfo::VT_NAME, name);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ScaleInfo::VT_SCALE, scale, 0.0f);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(ScaleInfo::VT_ZERO_POINT, zero_point, 0);
  }
  void add_dtype(chatty::DType dtype) {
    fbb_.AddElement<int8_t>(ScaleInfo::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  explicit ScaleInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScaleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScaleInfo>(end);
    fbb_.Required(o, ScaleInfo::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<ScaleInfo> CreateScaleInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    float scale = 0.0f,
    int32_t zero_point = 0,
    chatty::DType dtype = chatty::DType_NONE) {
  ScaleInfoBuilder builder_(_fbb);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_name(name);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ScaleInfo> CreateScaleInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float scale = 0.0f,
    int32_t zero_point = 0,
    chatty::DType dtype = chatty::DType_NONE) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return chatty::CreateScaleInfo(
      _fbb,
      name__,
      scale,
      zero_point,
      dtype);
}

struct Norm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_EPSILON = 10,
    VT_SCALE_X = 12,
    VT_SCALE_O = 14
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const chatty::Tensor *weight() const {
    return GetPointer<const chatty::Tensor *>(VT_WEIGHT);
  }
  const chatty::Tensor *bias() const {
    return GetPointer<const chatty::Tensor *>(VT_BIAS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  const chatty::ScaleInfo *scale_x() const {
    return GetPointer<const chatty::ScaleInfo *>(VT_SCALE_X);
  }
  const chatty::ScaleInfo *scale_o() const {
    return GetPointer<const chatty::ScaleInfo *>(VT_SCALE_O);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_WEIGHT) &&
           verifier.VerifyTable(weight()) &&
           VerifyOffsetRequired(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           VerifyOffset(verifier, VT_SCALE_X) &&
           verifier.VerifyTable(scale_x()) &&
           VerifyOffset(verifier, VT_SCALE_O) &&
           verifier.VerifyTable(scale_o()) &&
           verifier.EndTable();
  }
};

struct NormBuilder {
  typedef Norm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Norm::VT_TYPE, type);
  }
  void add_weight(::flatbuffers::Offset<chatty::Tensor> weight) {
    fbb_.AddOffset(Norm::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<chatty::Tensor> bias) {
    fbb_.AddOffset(Norm::VT_BIAS, bias);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(Norm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_scale_x(::flatbuffers::Offset<chatty::ScaleInfo> scale_x) {
    fbb_.AddOffset(Norm::VT_SCALE_X, scale_x);
  }
  void add_scale_o(::flatbuffers::Offset<chatty::ScaleInfo> scale_o) {
    fbb_.AddOffset(Norm::VT_SCALE_O, scale_o);
  }
  explicit NormBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Norm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Norm>(end);
    fbb_.Required(o, Norm::VT_TYPE);
    fbb_.Required(o, Norm::VT_WEIGHT);
    fbb_.Required(o, Norm::VT_BIAS);
    return o;
  }
};

inline ::flatbuffers::Offset<Norm> CreateNorm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<chatty::Tensor> weight = 0,
    ::flatbuffers::Offset<chatty::Tensor> bias = 0,
    float epsilon = 0.0f,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale_x = 0,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale_o = 0) {
  NormBuilder builder_(_fbb);
  builder_.add_scale_o(scale_o);
  builder_.add_scale_x(scale_x);
  builder_.add_epsilon(epsilon);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Norm> CreateNormDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    ::flatbuffers::Offset<chatty::Tensor> weight = 0,
    ::flatbuffers::Offset<chatty::Tensor> bias = 0,
    float epsilon = 0.0f,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale_x = 0,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale_o = 0) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return chatty::CreateNorm(
      _fbb,
      type__,
      weight,
      bias,
      epsilon,
      scale_x,
      scale_o);
}

struct LinearLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinearLayerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LinearLayerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHT = 4,
    VT_BIAS = 6,
    VT_ACTIVATION = 8,
    VT_SCALE_X = 10,
    VT_SCALE_O = 12
  };
  const chatty::Tensor *weight() const {
    return GetPointer<const chatty::Tensor *>(VT_WEIGHT);
  }
  const chatty::Tensor *bias() const {
    return GetPointer<const chatty::Tensor *>(VT_BIAS);
  }
  chatty::ActivationBits activation() const {
    return static_cast<chatty::ActivationBits>(GetField<int8_t>(VT_ACTIVATION, 0));
  }
  const chatty::ScaleInfo *scale_x() const {
    return GetPointer<const chatty::ScaleInfo *>(VT_SCALE_X);
  }
  const chatty::ScaleInfo *scale_o() const {
    return GetPointer<const chatty::ScaleInfo *>(VT_SCALE_O);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WEIGHT) &&
           verifier.VerifyTable(weight()) &&
           VerifyOffsetRequired(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION, 1) &&
           VerifyOffset(verifier, VT_SCALE_X) &&
           verifier.VerifyTable(scale_x()) &&
           VerifyOffset(verifier, VT_SCALE_O) &&
           verifier.VerifyTable(scale_o()) &&
           verifier.EndTable();
  }
};

struct LinearLayerBuilder {
  typedef LinearLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_weight(::flatbuffers::Offset<chatty::Tensor> weight) {
    fbb_.AddOffset(LinearLayer::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<chatty::Tensor> bias) {
    fbb_.AddOffset(LinearLayer::VT_BIAS, bias);
  }
  void add_activation(chatty::ActivationBits activation) {
    fbb_.AddElement<int8_t>(LinearLayer::VT_ACTIVATION, static_cast<int8_t>(activation), 0);
  }
  void add_scale_x(::flatbuffers::Offset<chatty::ScaleInfo> scale_x) {
    fbb_.AddOffset(LinearLayer::VT_SCALE_X, scale_x);
  }
  void add_scale_o(::flatbuffers::Offset<chatty::ScaleInfo> scale_o) {
    fbb_.AddOffset(LinearLayer::VT_SCALE_O, scale_o);
  }
  explicit LinearLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinearLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinearLayer>(end);
    fbb_.Required(o, LinearLayer::VT_WEIGHT);
    fbb_.Required(o, LinearLayer::VT_BIAS);
    return o;
  }
};

inline ::flatbuffers::Offset<LinearLayer> CreateLinearLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<chatty::Tensor> weight = 0,
    ::flatbuffers::Offset<chatty::Tensor> bias = 0,
    chatty::ActivationBits activation = chatty::ActivationBits_INT4,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale_x = 0,
    ::flatbuffers::Offset<chatty::ScaleInfo> scale_o = 0) {
  LinearLayerBuilder builder_(_fbb);
  builder_.add_scale_o(scale_o);
  builder_.add_scale_x(scale_x);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_activation(activation);
  return builder_.Finish();
}

struct AttentionLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttentionLayerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttentionLayerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K_PROJ = 4,
    VT_V_PROJ = 6,
    VT_Q_PROJ = 8,
    VT_O_PROJ = 10,
    VT_NORM = 12
  };
  const chatty::LinearLayer *k_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_K_PROJ);
  }
  const chatty::LinearLayer *v_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_V_PROJ);
  }
  const chatty::LinearLayer *q_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_Q_PROJ);
  }
  const chatty::LinearLayer *o_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_O_PROJ);
  }
  const chatty::Norm *norm() const {
    return GetPointer<const chatty::Norm *>(VT_NORM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_K_PROJ) &&
           verifier.VerifyTable(k_proj()) &&
           VerifyOffsetRequired(verifier, VT_V_PROJ) &&
           verifier.VerifyTable(v_proj()) &&
           VerifyOffsetRequired(verifier, VT_Q_PROJ) &&
           verifier.VerifyTable(q_proj()) &&
           VerifyOffsetRequired(verifier, VT_O_PROJ) &&
           verifier.VerifyTable(o_proj()) &&
           VerifyOffsetRequired(verifier, VT_NORM) &&
           verifier.VerifyTable(norm()) &&
           verifier.EndTable();
  }
};

struct AttentionLayerBuilder {
  typedef AttentionLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_k_proj(::flatbuffers::Offset<chatty::LinearLayer> k_proj) {
    fbb_.AddOffset(AttentionLayer::VT_K_PROJ, k_proj);
  }
  void add_v_proj(::flatbuffers::Offset<chatty::LinearLayer> v_proj) {
    fbb_.AddOffset(AttentionLayer::VT_V_PROJ, v_proj);
  }
  void add_q_proj(::flatbuffers::Offset<chatty::LinearLayer> q_proj) {
    fbb_.AddOffset(AttentionLayer::VT_Q_PROJ, q_proj);
  }
  void add_o_proj(::flatbuffers::Offset<chatty::LinearLayer> o_proj) {
    fbb_.AddOffset(AttentionLayer::VT_O_PROJ, o_proj);
  }
  void add_norm(::flatbuffers::Offset<chatty::Norm> norm) {
    fbb_.AddOffset(AttentionLayer::VT_NORM, norm);
  }
  explicit AttentionLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AttentionLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AttentionLayer>(end);
    fbb_.Required(o, AttentionLayer::VT_K_PROJ);
    fbb_.Required(o, AttentionLayer::VT_V_PROJ);
    fbb_.Required(o, AttentionLayer::VT_Q_PROJ);
    fbb_.Required(o, AttentionLayer::VT_O_PROJ);
    fbb_.Required(o, AttentionLayer::VT_NORM);
    return o;
  }
};

inline ::flatbuffers::Offset<AttentionLayer> CreateAttentionLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<chatty::LinearLayer> k_proj = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> v_proj = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> q_proj = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> o_proj = 0,
    ::flatbuffers::Offset<chatty::Norm> norm = 0) {
  AttentionLayerBuilder builder_(_fbb);
  builder_.add_norm(norm);
  builder_.add_o_proj(o_proj);
  builder_.add_q_proj(q_proj);
  builder_.add_v_proj(v_proj);
  builder_.add_k_proj(k_proj);
  return builder_.Finish();
}

struct FFNLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FFNLayerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FFNLayerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UP_PROJ = 4,
    VT_DOWN_PROJ = 6,
    VT_GATE_PROJ = 8,
    VT_NORM = 10,
    VT_ACT_LAYER = 12
  };
  const chatty::LinearLayer *up_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_UP_PROJ);
  }
  const chatty::LinearLayer *down_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_DOWN_PROJ);
  }
  const chatty::LinearLayer *gate_proj() const {
    return GetPointer<const chatty::LinearLayer *>(VT_GATE_PROJ);
  }
  const chatty::Norm *norm() const {
    return GetPointer<const chatty::Norm *>(VT_NORM);
  }
  chatty::ActLayer act_layer() const {
    return static_cast<chatty::ActLayer>(GetField<int8_t>(VT_ACT_LAYER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_UP_PROJ) &&
           verifier.VerifyTable(up_proj()) &&
           VerifyOffsetRequired(verifier, VT_DOWN_PROJ) &&
           verifier.VerifyTable(down_proj()) &&
           VerifyOffsetRequired(verifier, VT_GATE_PROJ) &&
           verifier.VerifyTable(gate_proj()) &&
           VerifyOffsetRequired(verifier, VT_NORM) &&
           verifier.VerifyTable(norm()) &&
           VerifyField<int8_t>(verifier, VT_ACT_LAYER, 1) &&
           verifier.EndTable();
  }
};

struct FFNLayerBuilder {
  typedef FFNLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_up_proj(::flatbuffers::Offset<chatty::LinearLayer> up_proj) {
    fbb_.AddOffset(FFNLayer::VT_UP_PROJ, up_proj);
  }
  void add_down_proj(::flatbuffers::Offset<chatty::LinearLayer> down_proj) {
    fbb_.AddOffset(FFNLayer::VT_DOWN_PROJ, down_proj);
  }
  void add_gate_proj(::flatbuffers::Offset<chatty::LinearLayer> gate_proj) {
    fbb_.AddOffset(FFNLayer::VT_GATE_PROJ, gate_proj);
  }
  void add_norm(::flatbuffers::Offset<chatty::Norm> norm) {
    fbb_.AddOffset(FFNLayer::VT_NORM, norm);
  }
  void add_act_layer(chatty::ActLayer act_layer) {
    fbb_.AddElement<int8_t>(FFNLayer::VT_ACT_LAYER, static_cast<int8_t>(act_layer), 0);
  }
  explicit FFNLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FFNLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FFNLayer>(end);
    fbb_.Required(o, FFNLayer::VT_UP_PROJ);
    fbb_.Required(o, FFNLayer::VT_DOWN_PROJ);
    fbb_.Required(o, FFNLayer::VT_GATE_PROJ);
    fbb_.Required(o, FFNLayer::VT_NORM);
    return o;
  }
};

inline ::flatbuffers::Offset<FFNLayer> CreateFFNLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<chatty::LinearLayer> up_proj = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> down_proj = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> gate_proj = 0,
    ::flatbuffers::Offset<chatty::Norm> norm = 0,
    chatty::ActLayer act_layer = chatty::ActLayer_NONE) {
  FFNLayerBuilder builder_(_fbb);
  builder_.add_norm(norm);
  builder_.add_gate_proj(gate_proj);
  builder_.add_down_proj(down_proj);
  builder_.add_up_proj(up_proj);
  builder_.add_act_layer(act_layer);
  return builder_.Finish();
}

struct TransformerLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformerLayerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransformerLayerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTN_LAYER = 4,
    VT_FFN_LAYER = 6
  };
  const chatty::AttentionLayer *attn_layer() const {
    return GetPointer<const chatty::AttentionLayer *>(VT_ATTN_LAYER);
  }
  const chatty::FFNLayer *ffn_layer() const {
    return GetPointer<const chatty::FFNLayer *>(VT_FFN_LAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ATTN_LAYER) &&
           verifier.VerifyTable(attn_layer()) &&
           VerifyOffsetRequired(verifier, VT_FFN_LAYER) &&
           verifier.VerifyTable(ffn_layer()) &&
           verifier.EndTable();
  }
};

struct TransformerLayerBuilder {
  typedef TransformerLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attn_layer(::flatbuffers::Offset<chatty::AttentionLayer> attn_layer) {
    fbb_.AddOffset(TransformerLayer::VT_ATTN_LAYER, attn_layer);
  }
  void add_ffn_layer(::flatbuffers::Offset<chatty::FFNLayer> ffn_layer) {
    fbb_.AddOffset(TransformerLayer::VT_FFN_LAYER, ffn_layer);
  }
  explicit TransformerLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransformerLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransformerLayer>(end);
    fbb_.Required(o, TransformerLayer::VT_ATTN_LAYER);
    fbb_.Required(o, TransformerLayer::VT_FFN_LAYER);
    return o;
  }
};

inline ::flatbuffers::Offset<TransformerLayer> CreateTransformerLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<chatty::AttentionLayer> attn_layer = 0,
    ::flatbuffers::Offset<chatty::FFNLayer> ffn_layer = 0) {
  TransformerLayerBuilder builder_(_fbb);
  builder_.add_ffn_layer(ffn_layer);
  builder_.add_attn_layer(attn_layer);
  return builder_.Finish();
}

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENIZERS = 4,
    VT_INPUT_EMBED = 6,
    VT_OUTPUT_NORM = 8,
    VT_OUTPUT_EMBED = 10,
    VT_LAYERS = 12,
    VT_HEAD_DIM = 14,
    VT_KV_NUM_HEADS = 16,
    VT_Q_NUM_HEADS = 18
  };
  const ::flatbuffers::Vector<int8_t> *tokenizers() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_TOKENIZERS);
  }
  const chatty::LinearLayer *input_embed() const {
    return GetPointer<const chatty::LinearLayer *>(VT_INPUT_EMBED);
  }
  const chatty::Norm *output_norm() const {
    return GetPointer<const chatty::Norm *>(VT_OUTPUT_NORM);
  }
  const chatty::LinearLayer *output_embed() const {
    return GetPointer<const chatty::LinearLayer *>(VT_OUTPUT_EMBED);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<chatty::TransformerLayer>> *layers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<chatty::TransformerLayer>> *>(VT_LAYERS);
  }
  int32_t head_dim() const {
    return GetField<int32_t>(VT_HEAD_DIM, 0);
  }
  int32_t kv_num_heads() const {
    return GetField<int32_t>(VT_KV_NUM_HEADS, 0);
  }
  int32_t q_num_heads() const {
    return GetField<int32_t>(VT_Q_NUM_HEADS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TOKENIZERS) &&
           verifier.VerifyVector(tokenizers()) &&
           VerifyOffsetRequired(verifier, VT_INPUT_EMBED) &&
           verifier.VerifyTable(input_embed()) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT_NORM) &&
           verifier.VerifyTable(output_norm()) &&
           VerifyOffset(verifier, VT_OUTPUT_EMBED) &&
           verifier.VerifyTable(output_embed()) &&
           VerifyOffsetRequired(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           VerifyField<int32_t>(verifier, VT_HEAD_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_KV_NUM_HEADS, 4) &&
           VerifyField<int32_t>(verifier, VT_Q_NUM_HEADS, 4) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tokenizers(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> tokenizers) {
    fbb_.AddOffset(Model::VT_TOKENIZERS, tokenizers);
  }
  void add_input_embed(::flatbuffers::Offset<chatty::LinearLayer> input_embed) {
    fbb_.AddOffset(Model::VT_INPUT_EMBED, input_embed);
  }
  void add_output_norm(::flatbuffers::Offset<chatty::Norm> output_norm) {
    fbb_.AddOffset(Model::VT_OUTPUT_NORM, output_norm);
  }
  void add_output_embed(::flatbuffers::Offset<chatty::LinearLayer> output_embed) {
    fbb_.AddOffset(Model::VT_OUTPUT_EMBED, output_embed);
  }
  void add_layers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<chatty::TransformerLayer>>> layers) {
    fbb_.AddOffset(Model::VT_LAYERS, layers);
  }
  void add_head_dim(int32_t head_dim) {
    fbb_.AddElement<int32_t>(Model::VT_HEAD_DIM, head_dim, 0);
  }
  void add_kv_num_heads(int32_t kv_num_heads) {
    fbb_.AddElement<int32_t>(Model::VT_KV_NUM_HEADS, kv_num_heads, 0);
  }
  void add_q_num_heads(int32_t q_num_heads) {
    fbb_.AddElement<int32_t>(Model::VT_Q_NUM_HEADS, q_num_heads, 0);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    fbb_.Required(o, Model::VT_TOKENIZERS);
    fbb_.Required(o, Model::VT_INPUT_EMBED);
    fbb_.Required(o, Model::VT_OUTPUT_NORM);
    fbb_.Required(o, Model::VT_LAYERS);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> tokenizers = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> input_embed = 0,
    ::flatbuffers::Offset<chatty::Norm> output_norm = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> output_embed = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<chatty::TransformerLayer>>> layers = 0,
    int32_t head_dim = 0,
    int32_t kv_num_heads = 0,
    int32_t q_num_heads = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_q_num_heads(q_num_heads);
  builder_.add_kv_num_heads(kv_num_heads);
  builder_.add_head_dim(head_dim);
  builder_.add_layers(layers);
  builder_.add_output_embed(output_embed);
  builder_.add_output_norm(output_norm);
  builder_.add_input_embed(input_embed);
  builder_.add_tokenizers(tokenizers);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *tokenizers = nullptr,
    ::flatbuffers::Offset<chatty::LinearLayer> input_embed = 0,
    ::flatbuffers::Offset<chatty::Norm> output_norm = 0,
    ::flatbuffers::Offset<chatty::LinearLayer> output_embed = 0,
    const std::vector<::flatbuffers::Offset<chatty::TransformerLayer>> *layers = nullptr,
    int32_t head_dim = 0,
    int32_t kv_num_heads = 0,
    int32_t q_num_heads = 0) {
  auto tokenizers__ = tokenizers ? _fbb.CreateVector<int8_t>(*tokenizers) : 0;
  auto layers__ = layers ? _fbb.CreateVector<::flatbuffers::Offset<chatty::TransformerLayer>>(*layers) : 0;
  return chatty::CreateModel(
      _fbb,
      tokenizers__,
      input_embed,
      output_norm,
      output_embed,
      layers__,
      head_dim,
      kv_num_heads,
      q_num_heads);
}

inline const ::flatbuffers::TypeTable *DTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::DTypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "INT8",
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT16",
    "FLOAT8",
    "BFLOAT16",
    "INT4"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 14, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ActivationBitsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::ActivationBitsTypeTable
  };
  static const char * const names[] = {
    "INT4",
    "INT8",
    "INT16",
    "FP16"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ActLayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::ActLayerTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RELU",
    "GELU",
    "SWISH",
    "SIGMOID",
    "TANH",
    "SOFTMAX"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::DTypeTypeTable,
    chatty::ScaleInfoTypeTable
  };
  static const char * const names[] = {
    "name",
    "shape",
    "dtype",
    "offset",
    "scale"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ScaleInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::DTypeTypeTable
  };
  static const char * const names[] = {
    "name",
    "scale",
    "zero_point",
    "dtype"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NormTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::TensorTypeTable,
    chatty::ScaleInfoTypeTable
  };
  static const char * const names[] = {
    "type",
    "weight",
    "bias",
    "epsilon",
    "scale_x",
    "scale_o"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *LinearLayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::TensorTypeTable,
    chatty::ActivationBitsTypeTable,
    chatty::ScaleInfoTypeTable
  };
  static const char * const names[] = {
    "weight",
    "bias",
    "activation",
    "scale_x",
    "scale_o"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AttentionLayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::LinearLayerTypeTable,
    chatty::NormTypeTable
  };
  static const char * const names[] = {
    "k_proj",
    "v_proj",
    "q_proj",
    "o_proj",
    "norm"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FFNLayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_CHAR, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::LinearLayerTypeTable,
    chatty::NormTypeTable,
    chatty::ActLayerTypeTable
  };
  static const char * const names[] = {
    "up_proj",
    "down_proj",
    "gate_proj",
    "norm",
    "act_layer"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TransformerLayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::AttentionLayerTypeTable,
    chatty::FFNLayerTypeTable
  };
  static const char * const names[] = {
    "attn_layer",
    "ffn_layer"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ModelTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    chatty::LinearLayerTypeTable,
    chatty::NormTypeTable,
    chatty::TransformerLayerTypeTable
  };
  static const char * const names[] = {
    "tokenizers",
    "input_embed",
    "output_norm",
    "output_embed",
    "layers",
    "head_dim",
    "kv_num_heads",
    "q_num_heads"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const chatty::Model *GetModel(const void *buf) {
  return ::flatbuffers::GetRoot<chatty::Model>(buf);
}

inline const chatty::Model *GetSizePrefixedModel(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<chatty::Model>(buf);
}

inline bool VerifyModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<chatty::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<chatty::Model>(nullptr);
}

inline void FinishModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<chatty::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<chatty::Model> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace chatty

#endif  // FLATBUFFERS_GENERATED_MODEL_CHATTY_H_
